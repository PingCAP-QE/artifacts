#!/usr/bin/env bash
# Code generated by ent, DO NOT EDIT.
set -euxo pipefail


function main() {
    local release_ws="build"
    local need_push="false" # true | false
    local result_path="result.yaml"
    parse_arguments "$@"

    compose {{.os}} {{.arch}} {{.version}} "${release_ws}"
{{- if has .artifactory "package_repo" }}
    if $need_push; then
        push_files "${release_ws}"
        write_push_results "$result_path"
    fi
{{- end }}
}

function parse_arguments() {
  while getopts ":w:o:ph" opt; do
    case ${opt} in
      w)
        release_ws=${OPTARG}
        ;;
      o)
        result_path=${OPTARG}
        ;;
      p)
        need_push=true
        ;;
      h)
        print_help
        exit 0
        ;;
      \?)
        echo "Invalid option: -$OPTARG" 1>&2
        exit 1
        ;;
      :)
        echo "Option -$OPTARG requires an argument." 1>&2
        exit 1
        ;;
    esac
  done
  shift $((OPTIND -1))
}

function print_help() {
  echo "Usage: ./your_script.sh [-w RELEASE_WS] [-o RESULT_PATH] [-b] [-h]"
  echo "Options:"
  echo "  -w RELEASE_WS   Set the release workspace path (default: build)"
  echo "  -p              Perform a push (default: false)"
  echo "  -o RESULT_PATH  Set the result yaml path (default: result.yaml)"
  echo "  -h              Show this help message"
}

function compose() {
{{- range $i, $artifact := .artifacts }}
    echo "ðŸš€ Start composing {{ .name }} package"
    compose_artifact{{ $i }} "$@"
    echo "âœ… Finished composing  {{ .name }} package"
{{ end }}
    echo "âœ… All done."
}

{{ range $i, $artifact := .artifacts }}
# Composing package: {{ $artifact.name }}"
function compose_artifact{{ $i }}() {
{{- with $artifact }}
    local os=$1
    local arch=$2
    local version=$3
    local release_ws=$4

    tiup mirror set --reset
    local archive_dir="{{ .name }}"
    rm -rf "$archive_dir"
    mkdir -p "$archive_dir"

    {{ $components := .components | jq `map(select(.if != false ))` }}
    ## fetch the public pkgs to another mirror.
    {{- with ($components | jq `map(select(.src.type == "tiup-clone"))`) }}
    {{- if gt (. | len)  0 }}
    tiup mirror clone $archive_dir \
    {{- range . }}
    {{ printf "  --%s %s" .name .src.version }} \
    {{- end }}
    --os $os --arch $arch
    {{- end }}
    {{- end }}

    ## self mirror to archive dir.
    tiup mirror set $archive_dir
    tiup_publish_options="--os $os --arch $arch --key $(ls $archive_dir/keys/*-pingcap.json | head -n 1)"

    ## pull tarballs from oci registry and publish to local tiup mirror.
    {{- range ($components | jq `map(select(.src.type == "oci"))`) }}
    # {{ .name }}
    oras pull {{ .src.url }}
    {{- if has .src "extract" }}
    tar -zxvf {{ .src.path }} --strip-components={{ math.Sub (strings.Split `/` (default "" .src.extract_inner_path) | len) 1 }} -C $archive_dir {{ default "" .src.extract_inner_path }}
    {{- else if has . "publish" }}
    tiup mirror publish {{ default .name .publish.name }} $version {{ .src.path }} {{ .publish.entrypoint }} ${tiup_publish_options}
    {{- else }}        
    mv {{ .src.path }} $archive_dir
    {{- end }}
    {{- end }}

    ## some pkgs need to re-publish
    {{- range ($components | jq `map(select(.src.type == "http"))`) }}
    # {{ .name }}
    wget {{ .src.url }}
    {{- if has .src "extract" }}
    tar -zxvf {{ path.Base .src.url }} --strip-components={{ math.Sub (strings.Split `/` (default "" .src.extract_inner_path) | len) 1 }} -C $archive_dir {{ default "" .src.extract_inner_path }}
    {{- else if has . "publish" }}    
    tiup mirror publish {{ default .name .publish.name }} $version {{ path.Base .src.url }} {{ .publish.entrypoint }} ${tiup_publish_options}
    {{- else }}        
    mv {{ path.Base .src.url }} $archive_dir
    {{- end }}
    {{- end }}

    ## list the tiup packages.
    tiup list --verbose

    ## shrink the size.
    rm -rf $archive_dir/commits

    ## archive it
    mkdir -p "$release_ws"
    local save_file="$release_ws/$archive_dir.tar.gz"
    tar -zcvf "$save_file" $archive_dir
    rm -rf $archive_dir
    echo "$save_file"
{{- end }}    
}
{{ end }}

{{- if has .artifactory "package_repo" }}
function prepare_artifact_config() {
    local save_file="$1"

    :> "$save_file"
    yq -p json -o json -i '.os = "{{ .os }}"' "$save_file"
    yq -p json -o json -i '.architecture = "{{ .arch }}"' "$save_file"
    yq -p json -o json -i '.edition = "{{ .edition }}"' "$save_file"
    yq -p json -o json -i '.version = "{{ .version }}"' "$save_file"
}

function push_files() {
    local release_ws="$1"

    local tag="{{ index .artifactory.tags 0 }}_{{ .os }}_{{ .arch }}"
    local destination="{{ .artifactory.package_repo  }}:$tag"

    prepare_artifact_config "$release_ws/artifact-config.json"

    # You should login before call this script, default it use credential with docker `config`` file: ~/.docker/config.json
    # Login steps:
    #   local registry=$(echo "${destination}" | cut -d/ -f)
    #   oras login -u ${ORAS_USER} -p ${ORAS_PASSWD} ${registry}

    pushd "$release_ws"
        oras push --artifact-type application/gzip --config artifact-config.json ${destination}
        {{- range (.artifacts | jq `map(select( .if != false ))`) }}{{ printf " %s.tar.gz" .name }}{{- end }}
        {{- range (.artifacts | jq `map(select( .if != false ))`) }}{{ printf " %s.tar.gz.sha256" .name }}{{- end }}
    popd

    {{- $tag_suffix := printf "_%s_%s" .os .arch -}}
    {{ $more_tags := (.artifactory.tags | jq `.[1:]`) }}
    {{ if gt (len $more_tags) 0 }}
    # add other tags.
    oras tag "${destination}" {{ range $more_tags }}{{ printf " %s%s" . $tag_suffix }}{{ end }}
    {{- end }}
}

function write_push_results() {
    local result_file="$1"
    local tag="{{ index .artifactory.tags 0 }}_{{ .os }}_{{ .arch }}"
    local destination="{{ .artifactory.package_repo  }}:$tag"

    # You should login before call this script, default it use credential with docker `config`` file: ~/.docker/config.json
    # Login steps:
    #   local registry=$(echo "${destination}" | cut -d/ -f)
    #   oras login -u ${ORAS_USER} -p ${ORAS_PASSWD} ${registry}
    digest="$(oras discover "${destination}" --distribution-spec v1.1-referrers-tag -o tree | cut -d@ -f2)"

    cat <<EOF > "$result_file"
oci:
  repo: {{ .artifactory.package_repo  }}
  tag: "$tag"
  digest: "$digest"
files:
  {{- range (.artifacts | jq `map(select( .if != false ))`) }}
  {{ printf "- %s.tar.gz" .name }}
  {{ printf "- %s.tar.gz.sha256" .name }}
  {{- end }}
EOF
}
{{- end }}

##############################################################################
###### Call the main function with the arguments passed to the script ########
main "$@"

#!/usr/bin/env bash
# Code generated by gomplate, DO NOT EDIT.

# It needs oras tools, but it can be run in different containers for separated stages.
# oras: https://oras.land/docs/category/oras-commands/

{{- $no_profile_tag_suffix := printf "_%s_%s"  .os .arch -}}
{{- $tag_suffix := $no_profile_tag_suffix -}}
{{- if ne .profile "release" }}
{{- $tag_suffix = printf "-%s%s" .profile $no_profile_tag_suffix -}}
{{- end }}

{{- $tags := coll.Slice }}
{{- $profile := .profile }}
{{- range $index, $tag := .artifactory.tags }}
{{- $suffix := $tag_suffix }}
{{- if or ($tag | strings.Contains $profile) ($tag | strings.Contains ($profile | strings.ReplaceAll "-" "")) }}
{{- $suffix = $no_profile_tag_suffix }}
{{- end }}
{{- $tags = append (printf "%s%s" $tag $suffix) $tags }}
{{- end }}

set -exo pipefail

function main() {
    local release_ws="build"
    local need_build="false" # true | false
    local need_package="false" # true | false
    local need_push="false" # true | false
    local result_path="result.yaml"
    parse_arguments "$@"

    if $need_build; then
        build
    fi
    if $need_package; then
        archive "${release_ws}"
    fi
{{- if has .artifactory "package_repo" }}
    if $need_push; then
        push_files "${release_ws}"
        write_push_results "$result_path"
    fi
{{- end }}
}

function parse_arguments() {
  while getopts ":w:o:abph" opt; do
    case ${opt} in
      w)
        release_ws=${OPTARG}
        ;;
      o)
        result_path=${OPTARG}
        ;;
      a)
        need_package=true
        ;;
      b)
        need_build=true
        ;;
      p)
        need_push=true
        ;;
      h)
        print_help
        exit 0
        ;;
      \?)
        echo "Invalid option: -$OPTARG" 1>&2
        exit 1
        ;;
      :)
        echo "Option -$OPTARG requires an argument." 1>&2
        exit 1
        ;;
    esac
  done
  shift $((OPTIND -1))
}

function print_help() {
  echo "Usage: ./your_script.sh [-w RELEASE_WS] [-o RESULT_PATH] [-b] [-h]"
  echo "Options:"
  echo "  -w RELEASE_WS   Set the release workspace path (default: build)"
  echo "  -b              Perform a build (default: false)"
  echo "  -a              Perform a package tarballs (default: false)"
  echo "  -p              Perform a push (default: false)"
  echo "  -o RESULT_PATH  Set the result yaml path (default: result.yaml)"
  echo "  -h              Show this help message"
}

# >>>>>>>>>>>>>>>> build steps >>>>>>>>>>>>>>>>
function build() {
    {{- $root := . -}}
    {{- if .steps }}{{- range .steps }}
    {{- if or (not (has . "os")) (eq .os $root.os) }}
{{ .script | indent 4 }}
    {{- end }}
    {{- end }}
    echo "building finished."
    {{- else }}
    echo "🏃 Skip: no build steps."
    {{- end }}
}

function fetch_file_from_oci_artifact() {
    local destination="$1"
    local to_match_file="$2"
    local repo="$(echo $destination | cut -d ':' -f 1)"

    # get the file blob digest.
    oras manifest fetch $destination | yq -e --prettyPrint -oy ".layers | filter(.annotations[\"org.opencontainers.image.title\"] | test \"$to_match_file\") | .[0]" >blob.yaml

    # download file
    file="$(yq .annotations[\"org.opencontainers.image.title\"] blob.yaml)"
    blob="$repo@$(yq .digest blob.yaml)"
    oras blob fetch --output $file $blob
    echo "$file"
}

function archive() {
    local release_ws="$1"
    mkdir -p ${release_ws}
    release_ws=$(realpath $release_ws)

    ################# create tarballs ################
    {{- range (.artifacts | jq `map(select((.type == "file" or .type == null) and .if != false))`) }}
    # >>>>>>>>>>>>>>>> file: {{ .name }} >>>>>>>>>>>>>>>>
    local save_file="$release_ws/{{ .name }}"
    {{- if has . "src" }}

    {{ if has .src "type" }}
    {{ test.Assert "Only support 'file' type" (eq .src.type "file") }}
    {{ end }}
    cp "{{ .src.path }}" "$save_file"

    {{- else }}

    echo "Start composing artifact: {{ .name }} ..."
    local archive_dir="$release_ws/$(uuidgen)"
    mkdir -p "$archive_dir"

    {{- $files := (.files | jq `map(select(.if != false ))`) -}}
    {{- $localFiles := ($files | jq `map(select(.src.type == "local" or .src.type == null))`) -}}
    {{- $ociFiles := $files | jq `map(select(.src.type == "oci"))` -}}
    {{- $httpFiles := $files | jq `map(select(.src.type == "http"))` -}}

    {{- if gt (len $localFiles) 0 }}
    ## local files
    {{- range $localFiles }}
    # - {{ .name }}
    mkdir -p "$(dirname ${archive_dir}/{{ .name }})"
    {{- if has .src "extract" }}
      {{- if strings.HasSuffix ".tar.gz" .src.path }}
    tar -zxvf {{ .src.path }} --strip-components={{ math.Sub (strings.Split `/` (default "" .src.extract_inner_path | strings.TrimSuffix "/") | len) 1 }} -C $archive_dir {{ default "" .src.extract_inner_path }}
      {{- else if strings.HasSuffix ".zip" .src.path }}
    unzip -j {{ .src.path }} {{ default "" .src.extract_inner_path }} -d $archive_dir
      {{- else }}
        {{ fail "Unsupported archive format, only support .tar.gz and .zip" }}
      {{- end }}
      {{- if and (has .src "extract_inner_path") (ne (path.Base .src.extract_inner_path) .name) }}
    mv $archive_dir/{{ path.Base .src.extract_inner_path }} ${archive_dir}/{{ .name }}
      {{- end }}
    {{- else }}
    cp -r {{ .src.path }} ${archive_dir}/{{ .name }}
    {{- end }}
    {{- end }}
    {{- end }}

    {{- if gt (len $ociFiles) 0 }}
    ## compose files from OCI repositories.
    {{- range $ociFiles }}
    # {{ .name }}
    tarball_file=$(fetch_file_from_oci_artifact {{ .src.url }} "{{ .src.path }}")
    mkdir -p $(dirname ${archive_dir}/{{ .name }})
    {{- if has .src "extract" }}
      {{- if strings.HasSuffix ".tar.gz" .src.path }}
    tar -zxvf $tarball_file --strip-components={{ math.Sub (strings.Split `/` (default "" .src.extract_inner_path | strings.TrimSuffix "/") | len) 1 }} -C $archive_dir {{ default "" .src.extract_inner_path }}
      {{- else if strings.HasSuffix ".zip" .src.path }}
    unzip -j $tarball_file {{ default "" .src.extract_inner_path }} -d $archive_dir
      {{- else }}
        {{ fail .src.path }}
      {{- end }}
      {{- if and (has .src "extract_inner_path") (ne (path.Base .src.extract_inner_path) .name) }}
    mv $archive_dir/{{ path.Base .src.extract_inner_path }} ${archive_dir}/{{ .name }}
      {{- end }}
    {{- else }}
    cp -r $tarball_file ${archive_dir}/{{ .name }}
    {{- end }}
    {{- end }}
    {{- end }}

    {{- if gt (len $httpFiles) 0 }}
    ## compose files from http.
    {{- range $httpFiles }}
    # {{ .name }}
    wget --tries=3 -c {{ .src.url }}
    mkdir -p $(dirname ${archive_dir}/{{ .name }})
    {{- if has .src "extract" }}
      {{- if strings.HasSuffix ".tar.gz" .src.url }}
    tar -zxvf {{ path.Base .src.url }} --strip-components={{ math.Sub (strings.Split `/` (default "" .src.extract_inner_path | strings.TrimSuffix "/") | len) 1 }} -C $archive_dir {{ default "" .src.extract_inner_path }}
      {{- else if strings.HasSuffix ".zip" .src.url }}
    unzip -j {{ path.Base .src.url }} {{ default "" .src.extract_inner_path }} -d $archive_dir
      {{- else }}
        {{ fail "Unsupported archive format, only support .tar.gz and .zip" }}
      {{- end }}
      {{- if and (has .src "extract_inner_path") (ne (path.Base .src.extract_inner_path) .name) }}
    mv $archive_dir/{{ path.Base .src.extract_inner_path }} ${archive_dir}/{{ .name }}
      {{- end }}
    {{- else }}
    cp -r {{ path.Base .src.url }} ${archive_dir}/{{ .name }}
    {{- end }}
    {{- end }}
    {{- end }}

    ## archive it
    pushd "$archive_dir"
    tar -zcvf "$save_file"
    {{- range $files }}{{ printf " %s" .name }}{{- end }}
    popd
    rm -rf $archive_dir
    {{- end }}

    echo "$save_file"
    sha256sum -b "$save_file" | cut -d ' ' -f1 > "$save_file.sha256"
    # <<<<<<<<<<<<<<<< file: {{ .name }} <<<<<<<<<<<<<<<<
    {{- end }}
}

{{ if has .artifactory "package_repo" -}}
function prepare_artifact_config() {
    local save_file="$1"

    :> "$save_file"
    yq -p json -o json -i '.["org.opencontainers.image.version"] = "{{ .version }}"' "$save_file"
    yq -p json -o json -i '.["net.pingcap.tibuild.os"] = "{{ .os }}"' "$save_file"
    yq -p json -o json -i '.["net.pingcap.tibuild.architecture"] = "{{ .arch }}"' "$save_file"
    yq -p json -o json -i '.["net.pingcap.tibuild.profile"] = "{{ .profile }}"' "$save_file"
    yq -p json -o json -i '.["net.pingcap.tibuild.git-sha"] = "{{ .git.sha }}"' "$save_file"
    yq -p json -o json -i '.["net.pingcap.tibuild.tiup"] = []' "$save_file"

    {{- if eq .profile "release" }}
    {{- range (.artifacts | jq `map(select((.type == "file" or .type == null) and .if != false and .tiup != null))`) }}
    {{- with .tiup }}
    yq -p json -o json -i '.["net.pingcap.tibuild.tiup"] += {{ . | toJSON }}' "$save_file"
    {{- end }}
    yq -p json -o json -i '.["net.pingcap.tibuild.tiup"][-1].file = "{{ .name }}"' "$save_file"
    {{- end }}
    {{- end }}
}


function push_files() {
    local release_ws="$1"
    local tag="{{ index $tags 0 }}"
    local destination="{{ .artifactory.package_repo }}:$tag"

    prepare_artifact_config "$release_ws/artifact-config.json"

    # You should login before call this script, default it use credential with docker `config`` file: ~/.docker/config.json
    # Login steps:
    #   local registry=$(echo "${destination}" | cut -d/ -f)
    #   oras login -u ${ORAS_USER} -p ${ORAS_PASSWD} ${registry}
    pushd "$release_ws"
        oras push --artifact-type application/gzip --config artifact-config.json ${destination}
        {{- range (.artifacts | jq `map(select((.type == "file" or .type == null) and .if != false))`) }}{{ printf " %s" .name }}{{- end }}
        {{- range (.artifacts | jq `map(select((.type == "file" or .type == null) and .if != false))`) }}{{ printf " %s.sha256" .name }}{{- end }}
    popd


    {{- if gt (len $tags) 1 }}
    # add other tags.
    oras tag {{ .artifactory.package_repo }}:{{ join $tags " " }}
    {{- end }}
}

function write_push_results() {
    local result_file="$1"
    local primary_tag="{{ index $tags 0 }}"
    local destination="{{ .artifactory.package_repo }}:$primary_tag"

    # You should login before call this script, default it use credential with docker `config`` file: ~/.docker/config.json
    # Login steps:
    #   local registry=$(echo "${destination}" | cut -d/ -f)
    #   oras login -u ${ORAS_USER} -p ${ORAS_PASSWD} ${registry}
    digest="$(oras discover "${destination}" --distribution-spec v1.1-referrers-tag --format tree | cut -d@ -f2)"

    cat <<EOF > "$result_file"
oci:
  repo: {{ .artifactory.package_repo }}
  tag: "$primary_tag"
  digest: "$digest"
files:
  {{- range (.artifacts | jq `map(select((.type == "file" or .type == null) and .if != false))`) }}
  {{ printf "- %s" .name }}
  {{ printf "- %s.sha256" .name }}
  {{- end }}
EOF
}
{{- end }}

##############################################################################
###### Call the main function with the arguments passed to the script ########
main "$@"

#!/usr/bin/env bash
# Code generated by gomplate, DO NOT EDIT.

# It needs oras tools, but it can be run in different containers for separated stages.
# oras: https://oras.land/docs/category/oras-commands/

{{- $no_profile_tag_suffix := printf "_%s_%s"  .os .arch -}}
{{- $tag_suffix := $no_profile_tag_suffix -}}
{{- if ne .profile "release" }}
{{- $tag_suffix = printf "-%s%s" .profile $no_profile_tag_suffix -}}
{{- end }}

{{- $tags := coll.Slice }}
{{- $profile := .profile }}
{{- range $index, $tag := .artifactory.tags }}
{{- $suffix := $tag_suffix }}
{{- if or ($tag | strings.Contains $profile) ($tag | strings.Contains ($profile | strings.ReplaceAll "-" "")) }}
{{- $suffix = $no_profile_tag_suffix }}
{{- end }}
{{- $tags = append (printf "%s%s" $tag $suffix) $tags }}
{{- end }}
{{- $tags = ($tags | coll.Uniq) }}

set -exo pipefail

function main() {
    parse_arguments "$@"

    if [ "$NEED_BUILD" = "true" ]; then
        build
    fi
    if [ "$NEED_PACKAGE" = "true" ]; then
        archive "${RELEASE_WS}"
    fi

{{- if has .artifactory "package_repo" }}
    if [ "$NEED_PUSH_OCI" = "true" ]; then
        push_files "${RELEASE_WS}"
        write_push_results "$PUSH_RESULT_SAVE_FILE"
        # push other tags
        if [ "$NEED_TAG_MORE" = "true" ]; then
          add_more_tags "${PUSH_RESULT_SAVE_FILE}"
        fi
    fi
{{- end }}
}

function parse_arguments() {
  RELEASE_WS="build"
  NEED_BUILD="false" # true | false
  NEED_PACKAGE="false" # true | false
  NEED_PUSH_OCI="false" # true | false
  NEED_TAG_MORE="true" # true | false
  PUSH_RESULT_SAVE_FILE="result.yaml"

  while getopts ":w:o:abpth" opt; do
    case ${opt} in
      w)
        RELEASE_WS=${OPTARG}
        ;;
      o)
        PUSH_RESULT_SAVE_FILE=${OPTARG}
        ;;
      a)
        NEED_PACKAGE=true
        ;;
      b)
        NEED_BUILD=true
        ;;
      p)
        NEED_PUSH_OCI=true
        ;;
      t)
        NEED_TAG_MORE=true
        ;;
      h)
        print_help
        exit 0
        ;;
      \?)
        echo "Invalid option: -$OPTARG" 1>&2
        exit 1
        ;;
      :)
        echo "Option -$OPTARG requires an argument." 1>&2
        exit 1
        ;;
    esac
  done
  shift $((OPTIND -1))
}

function print_help() {
  echo "Usage: ./your_script.sh [-w RELEASE_WS] [-o RESULT_PATH] [-b] [-h]"
  echo "Options:"
  echo "  -w RELEASE_WS   Set the release workspace path (default: build)"
  echo "  -b              Perform a build (default: false)"
  echo "  -a              Perform a package tarballs (default: false)"
  echo "  -p              Perform a push (default: false)"
  echo "  -t              Enable add more tags, else just pushed for first tag (default ture)"
  echo "  -o RESULT_PATH  Set the result yaml path (default: result.yaml)"
  echo "  -h              Show this help message"
}

# >>>>>>>>>>>>>>>> build steps >>>>>>>>>>>>>>>>
function build() {
    {{- $root := . -}}
    {{- if .steps }}{{- range .steps }}
    {{- if and (or (not (has . "os")) (eq .os $root.os)) (or (not (has . "os")) (eq .arch $root.arch))  }}
{{ .script | indent 4 }}
    {{- end }}
    {{- end }}
    echo "building finished."
    {{- else }}
    echo "ðŸƒ Skip: no build steps."
    {{- end }}
}

function fetch_file_from_oci_artifact() {
    local destination="$1"
    local to_match_file="$2"
    local repo="$(echo $destination | cut -d ':' -f 1)"

    # get the file blob digest.
    oras manifest fetch $destination | yq -e --prettyPrint -oy ".layers | filter(.annotations[\"org.opencontainers.image.title\"] | test \"$to_match_file\") | .[0]" >blob.yaml

    # download file
    file="$(yq .annotations[\"org.opencontainers.image.title\"] blob.yaml)"
    blob="$repo@$(yq .digest blob.yaml)"
    oras blob fetch --output $file $blob
    echo "$file"
}

function archive() {
    local release_ws="$1"
    mkdir -p ${release_ws}
    release_ws=$(realpath $release_ws)

    ################# create tarballs ################
    {{- range (.artifacts | jq `map(select((.type == "file" or .type == null) and .if != false))`) }}
    # >>>>>>>>>>>>>>>> file: {{ .name }} >>>>>>>>>>>>>>>>
    local save_file="$release_ws/{{ .name }}"
    {{- if has . "src" }}

    {{ if has .src "type" }}
    {{ test.Assert "Only support 'file' type" (eq .src.type "file") }}
    {{ end }}
    cp "{{ .src.path }}" "$save_file"

    {{- else }}

    echo "Start composing artifact: {{ .name }} ..."
    local archive_dir="$release_ws/$(uuidgen)"
    mkdir -p "$archive_dir"

    {{- $files := (.files | jq `map(select(.if != false ))`) -}}
    {{- $localFiles := ($files | jq `map(select(.src.type == "local" or .src.type == null))`) -}}
    {{- $ociFiles := $files | jq `map(select(.src.type == "oci"))` -}}
    {{- $httpFiles := $files | jq `map(select(.src.type == "http"))` -}}

    {{- if gt (len $localFiles) 0 }}
    ## local files
    {{- range $localFiles }}
    # - {{ .name }}
    mkdir -p "$(dirname ${archive_dir}/{{ .name }})"
    {{- if has .src "extract" }}
      {{- if strings.HasSuffix ".tar.gz" .src.path }}
    tar -zxvf {{ .src.path }} --strip-components={{ math.Sub (strings.Split `/` (default "" .src.extract_inner_path | strings.TrimSuffix "/") | len) 1 }} -C $archive_dir {{ default "" .src.extract_inner_path }}
      {{- else if strings.HasSuffix ".zip" .src.path }}
    unzip -j {{ .src.path }} {{ default "" .src.extract_inner_path }} -d $archive_dir
      {{- else }}
        {{ fail "Unsupported archive format, only support .tar.gz and .zip" }}
      {{- end }}
      {{- if and (has .src "extract_inner_path") (ne (path.Base .src.extract_inner_path) .name) }}
    mv $archive_dir/{{ path.Base .src.extract_inner_path }} ${archive_dir}/{{ .name }}
      {{- end }}
    {{- else }}
    cp -r {{ .src.path }} ${archive_dir}/{{ .name }}
    {{- end }}
    {{- end }}
    {{- end }}

    {{- if gt (len $ociFiles) 0 }}
    ## compose files from OCI repositories.
    {{- range $ociFiles }}
    # {{ .name }}
    tarball_file=$(fetch_file_from_oci_artifact {{ .src.url }} "{{ .src.path }}")
    mkdir -p $(dirname ${archive_dir}/{{ .name }})
    {{- if has .src "extract" }}
      {{- if strings.HasSuffix ".tar.gz" .src.path }}
    tar -zxvf $tarball_file --strip-components={{ math.Sub (strings.Split `/` (default "" .src.extract_inner_path | strings.TrimSuffix "/") | len) 1 }} -C $archive_dir {{ default "" .src.extract_inner_path }}
      {{- else if strings.HasSuffix ".zip" .src.path }}
    unzip -j $tarball_file {{ default "" .src.extract_inner_path }} -d $archive_dir
      {{- else }}
        {{ fail .src.path }}
      {{- end }}
      {{- if and (has .src "extract_inner_path") (ne (path.Base .src.extract_inner_path) .name) }}
    mv $archive_dir/{{ path.Base .src.extract_inner_path }} ${archive_dir}/{{ .name }}
      {{- end }}
    {{- else }}
    cp -r $tarball_file ${archive_dir}/{{ .name }}
    {{- end }}
    {{- end }}
    {{- end }}

    {{- if gt (len $httpFiles) 0 }}
    ## compose files from http.
    {{- range $httpFiles }}
    # {{ .name }}
    wget --tries=3 -c {{ .src.url }}
    mkdir -p $(dirname ${archive_dir}/{{ .name }})
    {{- if has .src "extract" }}
      {{- if strings.HasSuffix ".tar.gz" .src.url }}
    tar -zxvf {{ path.Base .src.url }} --strip-components={{ math.Sub (strings.Split `/` (default "" .src.extract_inner_path | strings.TrimSuffix "/") | len) 1 }} -C $archive_dir {{ default "" .src.extract_inner_path }}
      {{- else if strings.HasSuffix ".zip" .src.url }}
    unzip -j {{ path.Base .src.url }} {{ default "" .src.extract_inner_path }} -d $archive_dir
      {{- else }}
        {{ fail "Unsupported archive format, only support .tar.gz and .zip" }}
      {{- end }}
      {{- if and (has .src "extract_inner_path") (ne (path.Base .src.extract_inner_path) .name) }}
    mv $archive_dir/{{ path.Base .src.extract_inner_path }} ${archive_dir}/{{ .name }}
      {{- end }}
    {{- else }}
    cp -r {{ path.Base .src.url }} ${archive_dir}/{{ .name }}
    {{- end }}
    {{- end }}
    {{- end }}

    ## archive it
    pushd "$archive_dir"
    tar -zcvf "$save_file"
    {{- range $files }}{{ printf " %s" .name }}{{- end }}
    popd
    rm -rf $archive_dir
    {{- end }}

    echo "$save_file"
    sha256sum -b "$save_file" | cut -d ' ' -f1 > "$save_file.sha256"
    # <<<<<<<<<<<<<<<< file: {{ .name }} <<<<<<<<<<<<<<<<
    {{- end }}
}

{{ if has .artifactory "package_repo" -}}
function prepare_artifact_config() {
    local save_file="$1"

    :> "$save_file"
    # Inject OCI standard metadata labels and PingCAP build labels.
    yq -p json -o json -i '
        .["org.opencontainers.image.version"] = "{{ .version }}" |
        .["org.opencontainers.image.title"] = "{{ .component }}" |
        .["org.opencontainers.image.licenses"] = "{{ .license | default "Apache-2.0" }}" |
        .["org.opencontainers.image.source"] = "{{ .git.url }}" |
        .["org.opencontainers.image.ref.name"] = "{{ .git.ref }}" |
        .["org.opencontainers.image.revision"] = "{{ .git.sha }}" |
        .["net.pingcap.tibuild.os"] = "{{ .os }}" |
        .["net.pingcap.tibuild.architecture"] = "{{ .arch }}" |
        .["net.pingcap.tibuild.profile"] = "{{ .profile }}" |
        .["net.pingcap.tibuild.git-sha"] = "{{ .git.sha }}" |
        .["net.pingcap.tibuild.tiup"] = []
    ' "$save_file"

    {{- if has (coll.Slice "release" "next-gen") .profile }}
    {{- range (.artifacts | jq `map(select((.type == "file" or .type == null) and .if != false and .tiup != null))`) }}
    {{- with .tiup }}
    yq -p json -o json -i '.["net.pingcap.tibuild.tiup"] += {{ . | toJSON }}' "$save_file"
    {{- end }}
    yq -p json -o json -i '.["net.pingcap.tibuild.tiup"][-1].file = "{{ .name }}"' "$save_file"
    {{- end }}
    {{- end }}
}


function push_files() {
    local release_ws="$1"
    local tag="{{ index $tags 0 }}"
    local destination="{{ .artifactory.package_repo }}:$tag"

    prepare_artifact_config "$release_ws/artifact-config.json"

    # You should login before call this script, default it use credential with docker `config`` file: ~/.docker/config.json
    # Login steps:
    #   local registry=$(echo "${destination}" | cut -d/ -f)
    #   oras login -u ${ORAS_USER} -p ${ORAS_PASSWD} ${registry}
    pushd "$release_ws"
        oras push --artifact-type application/gzip --config artifact-config.json ${destination}
        {{- range (.artifacts | jq `map(select((.type == "file" or .type == null) and .if != false))`) }}{{ printf " %s" .name }}{{- end }}
        {{- range (.artifacts | jq `map(select((.type == "file" or .type == null) and .if != false))`) }}{{ printf " %s.sha256" .name }}{{- end }}
    popd
}

function write_push_results() {
    local result_file="$1"
    local primary_tag="{{ index $tags 0 }}"
    local destination="{{ .artifactory.package_repo }}:$primary_tag"

    # You should login before call this script, default it use credential with docker `config`` file: ~/.docker/config.json
    # Login steps:
    #   local registry=$(echo "${destination}" | cut -d/ -f)
    #   oras login -u ${ORAS_USER} -p ${ORAS_PASSWD} ${registry}
    digest="$(oras discover "${destination}" --distribution-spec v1.1-referrers-tag --format tree | cut -d@ -f2)"

    cat <<EOF > "$result_file"
oci:
  repo: {{ .artifactory.package_repo }}
  tag: "$primary_tag"
  digest: "$digest"
files:
  {{- range (.artifacts | jq `map(select((.type == "file" or .type == null) and .if != false))`) }}
  {{ printf "- %s" .name }}
  {{ printf "- %s.sha256" .name }}
  {{- end }}
EOF
}

add_more_tags() {
    result_file="$1"
    {{- if gt (len $tags) 1 }}
    # add other tags.
    oras tag {{ .artifactory.package_repo }}:{{ join $tags " " }}
    yq -i '.oci.tags = ["{{ join $tags "\",\"" }}"]' "$result_file"
    {{- else }}
    echo "ðŸ¤· No more tags need to be tagged."
    {{- end }}
}
{{- end }}

##############################################################################
###### Call the main function with the arguments passed to the script ########
main "$@"

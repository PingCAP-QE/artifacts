#!/usr/bin/env bash
# Code generated by gomplate, DO NOT EDIT.

set -exo pipefail

function main() {
    local release_ws="build"
    local need_build="false" # true | false
    local need_package="false" # true | false
    local need_push="false" # true | false
    local result_path="result.yaml"
    parse_arguments "$@"

    if $need_build; then
        build
    fi
    if $need_package; then
        archive "${release_ws}"
    fi
{{- if has .artifactory "package_repo" }}
    if $need_push; then
        push_files "${release_ws}"
        write_push_results "$result_path"
    fi
{{- end }}
}

function parse_arguments() {
  while getopts ":w:o:abph" opt; do
    case ${opt} in
      w)
        release_ws=${OPTARG}
        ;;
      o)
        result_path=${OPTARG}
        ;;
      a)
        need_package=true
        ;;
      b)
        need_build=true
        ;;
      p)
        need_push=true
        ;;
      h)
        print_help
        exit 0
        ;;
      \?)
        echo "Invalid option: -$OPTARG" 1>&2
        exit 1
        ;;
      :)
        echo "Option -$OPTARG requires an argument." 1>&2
        exit 1
        ;;
    esac
  done
  shift $((OPTIND -1))
}

function print_help() {
  echo "Usage: ./your_script.sh [-w RELEASE_WS] [-o RESULT_PATH] [-b] [-h]"
  echo "Options:"
  echo "  -w RELEASE_WS   Set the release workspace path (default: build)"
  echo "  -b              Perform a build (default: false)"
  echo "  -a              Perform a package tarballs (default: false)"
  echo "  -p              Perform a push (default: false)"
  echo "  -o RESULT_PATH  Set the result yaml path (default: result.yaml)"
  echo "  -h              Show this help message"
}

# >>>>>>>>>>>>>>>> build steps >>>>>>>>>>>>>>>>
function build() {
    {{- $root := . -}}
    {{- if .steps }}{{- range .steps }}
    {{- if or (not (has . "os")) (eq .os $root.os) }}
{{ .script | indent 4 }}
    {{- end }}
    {{- end }}
    echo "building finished."
    {{- else }}
    echo "🏃 Skip: no build steps."
    {{- end }}
}

function fetch_file_from_oci_artifact() {
    local destination="$1"
    local to_match_file="$2"
    local repo="$(echo $destination | cut -d ':' -f 1)"

    # get the file blob digest.
    oras manifest fetch $destination | yq -e --prettyPrint ".layers | filter(.annotations[\"org.opencontainers.image.title\"] | test \"$to_match_file\") | .[0]" >blob.yaml

    # download file
    file="$(yq .annotations[\"org.opencontainers.image.title\"] blob.yaml)"
    blob="$repo@$(yq .digest blob.yaml)"
    oras blob fetch --output $file $blob
    echo "$file"
}

function archive() {
    local release_ws="$1"
    mkdir -p ${release_ws}
    release_ws=$(realpath $release_ws)

    ################# create tarballs ################
    {{- range (.artifacts | jq `map(select((.type == "file" or .type == null) and .if != false))`) }}
    # >>>>>>>>>>>>>>>> file: {{ .name }} >>>>>>>>>>>>>>>>
    local save_file="$release_ws/{{ .name }}"
    {{- if has . "src" }}

    {{ if has .src "type" }}
    {{ test.Assert "Only support 'file' type" (eq .src.type "file") }}
    {{ end }}
    cp "{{ .src.path }}" "$save_file"

    {{- else }}

    echo "Start composing artifact: {{ .name }} ..."
    local archive_dir="$release_ws/$(uuidgen)"
    mkdir -p "$archive_dir"

    {{- $files := (.files | jq `map(select(.if != false ))`) -}}
    {{- $localFiles := ($files | jq `map(select(.src.type == "local" or .src.type == null))`) -}}
    {{- $ociFiles := $files | jq `map(select(.src.type == "oci"))` -}}
    {{- $httpFiles := $files | jq `map(select(.src.type == "http"))` -}}

    {{- if gt (len $localFiles) 0 }}
    ## local files
    {{- range $localFiles }}
    # - {{ .name }}
    mkdir -p "$(dirname ${archive_dir}/{{ .name }})"
    {{- if has .src "extract" }}
    tar -zxvf {{ .src.path }} --strip-components={{ math.Sub (strings.Split `/` (default "" .src.extract_inner_path | strings.TrimSuffix "/") | len) 1 }} -C $archive_dir {{ default "" .src.extract_inner_path }}
      {{- if and (has .src "extract_inner_path") (ne (path.Base .src.extract_inner_path) .name) }}
    mv $archive_dir/{{ path.Base .src.extract_inner_path }} ${archive_dir}/{{ .name }}
      {{- end }}
    {{- else }}
    cp -r {{ .src.path }} ${archive_dir}/{{ .name }}
    {{- end }}
    {{- end }}
    {{- end }}

    {{- if gt (len $ociFiles) 0 }}
    ## compose files from OCI repositories.
    {{- range $ociFiles }}
    # {{ .name }}
    tarball_file=$(fetch_file_from_oci_artifact {{ .src.url }} "{{ .src.path }}")
    mkdir -p $(dirname ${archive_dir}/{{ .name }})
    {{- if has .src "extract" }}
    tar -zxvf $tarball_file --strip-components={{ math.Sub (strings.Split `/` (default "" .src.extract_inner_path | strings.TrimSuffix "/") | len) 1 }} -C $archive_dir {{ default "" .src.extract_inner_path }}
      {{- if and (has .src "extract_inner_path") (ne (path.Base .src.extract_inner_path) .name) }}
    mv $archive_dir/{{ path.Base .src.extract_inner_path }} ${archive_dir}/{{ .name }}
      {{- end }}
    {{- else }}
    cp -r $tarball_file ${archive_dir}/{{ .name }}
    {{- end }}
    {{- end }}
    {{- end }}

    {{- if gt (len $httpFiles) 0 }}
    ## compose files from http.
    {{- range $httpFiles }}
    # {{ .name }}
    wget {{ .src.url }}
    mkdir -p $(dirname ${archive_dir}/{{ .name }})
    {{- if has .src "extract" }}
    tar -zxvf {{ path.Base .src.url }} --strip-components={{ math.Sub (strings.Split `/` (default "" .src.extract_inner_path | strings.TrimSuffix "/") | len) 1 }} -C $archive_dir {{ default "" .src.extract_inner_path }}
      {{- if and (has .src "extract_inner_path") (ne (path.Base .src.extract_inner_path) .name) }}
    mv $archive_dir/{{ path.Base .src.extract_inner_path }} ${archive_dir}/{{ .name }}
      {{- end }}
    {{- else }}
    cp -r {{ path.Base .src.url }} ${archive_dir}/{{ .name }}
    {{- end }}
    {{- end }}
    {{- end }}

    ## archive it
    pushd "$archive_dir"
    tar -zcvf "$save_file"
    {{- range $files }}{{ printf " %s" .name }}{{- end }}
    popd
    rm -rf $archive_dir
    {{- end }}

    echo "$save_file"
    sha256sum -b "$save_file" | cut -d ' ' -f1 > "$save_file.sha256"
    # <<<<<<<<<<<<<<<< file: {{ .name }} <<<<<<<<<<<<<<<<
    {{- end }}
}

{{ if has .artifactory "package_repo" -}}
function prepare_artifact_config() {
    local save_file="$1"

    :> "$save_file"
    yq -p json -o json -i '.["org.opencontainers.image.version"] = "{{ .version }}"' "$save_file"
    yq -p json -o json -i '.["net.pingcap.tibuild.os"] = "{{ .os }}"' "$save_file"
    yq -p json -o json -i '.["net.pingcap.tibuild.architecture"] = "{{ .arch }}"' "$save_file"
    yq -p json -o json -i '.["net.pingcap.tibuild.profile"] = "{{ .profile }}"' "$save_file"    
    yq -p json -o json -i '.["net.pingcap.tibuild.tiup"] = []' "$save_file"

    {{- if eq .profile "release" }}
    {{- range (.artifacts | jq `map(select((.type == "file" or .type == null) and .if != false and .tiup != null))`) }}
    {{- with .tiup }}
    yq -p json -o json -i '.["net.pingcap.tibuild.tiup"] += {{ . | toJSON }}' "$save_file"
    {{- end }}
    yq -p json -o json -i '.["net.pingcap.tibuild.tiup"][-1].file = "{{ .name }}"' "$save_file"
    {{- end }}
    {{- end }}
}

function push_files() {
    local release_ws="$1"

    local tag="{{ index .artifactory.tags 0 }}{{ if ne .profile "release" }}-{{ .profile }}{{ end }}_{{ .os }}_{{ .arch }}"
    local destination="{{ .artifactory.package_repo  }}:$tag"

    prepare_artifact_config "$release_ws/artifact-config.json"

    # You should login before call this script, default it use credential with docker `config`` file: ~/.docker/config.json
    # Login steps:
    #   local registry=$(echo "${destination}" | cut -d/ -f)
    #   oras login -u ${ORAS_USER} -p ${ORAS_PASSWD} ${registry}

    pushd "$release_ws"
        oras push --artifact-type application/gzip --config artifact-config.json ${destination}
        {{- range (.artifacts | jq `map(select((.type == "file" or .type == null) and .if != false))`) }}{{ printf " %s" .name }}{{- end }}
        {{- range (.artifacts | jq `map(select((.type == "file" or .type == null) and .if != false))`) }}{{ printf " %s.sha256" .name }}{{- end }}
    popd

    {{- $tag_suffix := printf "_%s_%s"  .os .arch -}}
    {{- if ne .profile "release" }}
    {{- $tag_suffix := printf "-%s_%s_%s" .profile .os .arch -}}
    {{- end }}

    {{- $more_tags := (.artifactory.tags | jq `.[1:]`) -}}
    {{- if gt (len $more_tags) 0 }}
    # add other tags.
    oras tag "${destination}" {{ range $more_tags }}{{ printf " %s%s" . $tag_suffix }}{{ end }}
    {{- end }}
}

function write_push_results() {
    local result_file="$1"
    local tag="{{ index .artifactory.tags 0 }}{{ if ne .profile "release" }}-{{ .profile }}{{ end }}_{{ .os }}_{{ .arch }}"
    local destination="{{ .artifactory.package_repo  }}:$tag"

    # You should login before call this script, default it use credential with docker `config`` file: ~/.docker/config.json
    # Login steps:
    #   local registry=$(echo "${destination}" | cut -d/ -f)
    #   oras login -u ${ORAS_USER} -p ${ORAS_PASSWD} ${registry}
    digest="$(oras discover "${destination}" --distribution-spec v1.1-referrers-tag -o tree | cut -d@ -f2)"

    cat <<EOF > "$result_file"
oci:
  repo: {{ .artifactory.package_repo  }}
  tag: "$tag"
  digest: "$digest"
files:
  {{- range (.artifacts | jq `map(select((.type == "file" or .type == null) and .if != false))`) }}
  {{ printf "- %s" .name }}
  {{ printf "- %s.sha256" .name }}
  {{- end }}
EOF
}
{{- end }}

##############################################################################
###### Call the main function with the arguments passed to the script ########
main "$@"

#!/usr/bin/env bash
# Code generated by gomplate, DO NOT EDIT.

set -exo pipefail

function main() {
    local release_ws="build"
    local need_build="false" # true | false
    local need_package="false" # true | false
    local need_push="false" # true | false
    parse_arguments "$@"

    if $need_build; then
        build
    fi
    if $need_package; then
        archive "${release_ws}"
    fi
{{- if has .artifactory "repo" }}
    if $need_push; then
        push_files "${release_ws}"
    fi
{{- end }}
}

function parse_arguments() {
  while getopts ":w:abph" opt; do
    case ${opt} in
      w)
        release_ws=${OPTARG}
        ;;
      a)
        need_package=true
        ;;
      b)
        need_build=true
        ;;
      p)
        need_push=true
        ;;
      h)
        print_help
        exit 0
        ;;
      \?)
        echo "Invalid option: -$OPTARG" 1>&2
        exit 1
        ;;
      :)
        echo "Option -$OPTARG requires an argument." 1>&2
        exit 1
        ;;
    esac
  done
  shift $((OPTIND -1))
}

function print_help() {
  echo "Usage: ./your_script.sh [-w RELEASE_WS] [-b] [-h]"
  echo "Options:"
  echo "  -w RELEASE_WS   Set the release workspace path (default: /path/to/release/ws)"
  echo "  -b              Perform a build (default: false)"
  echo "  -a              Perform a package tarballs (default: false)"
  echo "  -p              Perform a push (default: false)"
  echo "  -h              Show this help message"
}

# >>>>>>>>>>>>>>>> build steps >>>>>>>>>>>>>>>>
function build() {
    {{- $root := . -}}
    {{- range .steps }}
    {{- if or (not (has . "os")) (eq .os $root.os) }}
{{ .script | indent 4 }}
    {{- end }}
    {{- end }}
}

function archive() {
    local release_ws="$1"
    local need_build="$2" # true or false
    mkdir -p ${release_ws}
    release_ws=$(realpath $release_ws)

    ################# create tarballs ################
    {{- range (.artifacts | jq `map(select(.type == "file" or .type == null))`) }}
    # >>>>>>>>>>>>>>>> file: {{ .name }} >>>>>>>>>>>>>>>>
    echo "Start composing artifact: {{ .name }} ..."
    local archive_dir="$release_ws/$(uuidgen)"
    mkdir -p "$archive_dir"

    {{- $files := (.files | jq `map(select(.if != false ))`) -}}
    {{- $localFiles := ($files | jq `map(select(.src.type == "local" or .src.type == null))`) -}}
    {{- $ociFiles := $files | jq `map(select(.src.type == "oci"))` -}}
    {{- $httpFiles := $files | jq `map(select(.src.type == "http"))` -}}

    {{- if gt (len $localFiles) 0 }}
    ## local files
    {{- range $localFiles }}
    # - {{ .name }}
    mkdir -p $(dirname ${archive_dir}/{{ .name }})
    {{- if has .src "extract" }}
    tar -zxvf {{ .src.path }} --strip-components={{ math.Sub (strings.Split `/` (default "" .src.extract_inner_path) | len) 1 }} -C $archive_dir {{ default "" .src.extract_inner_path }}
    mv {{ default "" .src.extract_inner_path }} ${archive_dir}/{{ .name }}
    {{- else }}
    cp -r {{ .src.path }} ${archive_dir}/{{ .name }}
    {{- end }}
    {{- end }}
    {{- end }}

    {{- if gt (len $ociFiles) 0 }}
    ## compose files from OCI repositories.
    {{- range $ociFiles }}
    # {{ .name }}
    oras pull {{ .src.url }}
    mkdir -p $(dirname ${archive_dir}/{{ .name }})
    {{- if has .src "extract" }}
    tar -zxvf {{ .src.path }} --strip-components={{ math.Sub (strings.Split `/` (default "" .src.extract_inner_path) | len) 1 }} -C $archive_dir {{ default "" .src.extract_inner_path }}
    mv {{ default "" .src.extract_inner_path }} {{ .name }}
    {{- else }}
    cp -r {{ .src.path }} ${archive_dir}/{{ .name }}
    {{- end }}
    {{- end }}
    {{- end }}

    {{- if gt (len $httpFiles) 0 }}
    ## compose files from http.
    {{- range $httpFiles }}
    # {{ .name }}
    wget {{ .src.url }}
    mkdir -p $(dirname ${archive_dir}/{{ .name }})
    {{- if has .src "extract" }}
    tar -zxvf {{ path.Base .src.url }} --strip-components={{ math.Sub (strings.Split `/` (default "" .src.extract_inner_path) | len) 1 }} -C $archive_dir {{ default "" .src.extract_inner_path }}
    {{- else }}
    cp -r {{ .src.path }} ${archive_dir}/{{ .name }}
    {{- end }}
    {{- end }}
    {{- end }}

    ## archive it
    local save_file="$release_ws/{{ .name }}"
    pushd "$archive_dir"
    tar -zcvf "$save_file"
    {{- range $files }}{{ printf " %s" .name }}{{- end }}
    popd
    rm -rf $archive_dir
    echo "$save_file"
    # <<<<<<<<<<<<<<<< file: {{ .name }} <<<<<<<<<<<<<<<<
    {{- end }}
}

{{- if has .artifactory "repo" }}
function push_files() {
    local release_ws="$1"

    local tag="{{ index .artifactory.tags 0 }}-{{ .profile }}_{{ .os }}_{{ .arch }}"
    local destination="{{ .artifactory.repo  }}:$tag"

    # You should login before call this script, default it use credential with docker `config`` file: ~/.docker/config.json
    # Login steps:
    #   local registry=$(echo "${destination}" | cut -d/ -f)
    #   oras login -u ${ORAS_USER} -p ${ORAS_PASSWD} ${registry}

    pushd "$release_ws"
        oras push --artifact-type application/gzip ${destination}
        {{- range (.artifacts | jq `map(select(.type == "file" or .type == null))`) }}{{ printf " %s" .name }}{{- end }}
    popd
}
{{- end }}

##############################################################################
###### Call the main function with the arguments passed to the script ########
main "$@"

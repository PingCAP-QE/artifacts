#!/bin/sh
# Code generated by gomplate, DO NOT EDIT.

set -exo pipefail

main() {
  parse_arguments "$@"

  # Access variables directly within the main function
  mkdir -p "${RELEASE_WS}"
  RELEASE_WS=$(realpath "${RELEASE_WS}")

  if [ "$NEED_BUILD" = "true" ]; then
    build_binaries
  fi

  build_and_push_images "${RELEASE_WS}" "${PUSH_RESULT_SAVE_FILE}" "${KANIKO_EXECUTOR}"
}

parse_arguments() {
  RELEASE_WS="build"
  NEED_BUILD="false" # Default value is false
  KANIKO_EXECUTOR="/kaniko/executor"

  while [ "$#" -gt 0 ]; do
    case "$1" in
      -w)
        RELEASE_WS="$2"
        shift 2
        ;;
      -b)
        NEED_BUILD="true"
        shift
        ;;
      -k)
        KANIKO_EXECUTOR="$2"
        shift 2
        ;;
      -o)
        PUSH_RESULT_SAVE_FILE="$2"
        shift 2
        ;;        
      -h)
        print_help
        exit 0
        ;;
      *)
        echo "Invalid option: $1" 1>&2
        exit 1
        ;;
    esac
  done
}

print_help() {
  echo "Usage: script_name [-w release_ws] [-b] [-k kaniko_executor]"
  echo "Options:"
  echo "  -w release_ws       Set the release workspace (default: 'build')"
  echo "  -o result_path      Set the result path (default: 'result-images.yaml')"
  echo "  -b                  Enable building"
  echo "  -k kaniko_executor  Set the Kaniko executor path (default: '/kaniko/executor')"
  echo "  -h                  Print this help message"
}

# >>>>>>>>>>>>>>>> build binaries steps >>>>>>>>>>>>>>>>
build_binaries() {
  {{- $root := . -}}
  {{- range .steps }}
  {{- if or (not (has . "os")) (eq .os $root.os) }}
{{ .script | indent 4 }}
  {{- end }}
  {{- end }}
  echo "building finished."
}

build_and_push_images() {
    release_ws="$1"
    result_file="$2"
    kaniko_executor="$3"

    ################# build and push image ################
    tag="{{ index .artifactory.tags 0 }}-{{ .profile }}_{{ .os }}_{{ .arch }}"
{{ range (.artifacts | jq `map(select(.type == "image"))`) }}
    # >>>>>>>>>>>>>>>> image: {{ .name }} >>>>>>>>>>>>>>>>
    archive_dir="$release_ws/tmp-$(date +%s)"
    mkdir -p "$archive_dir"
    destination="{{ .artifactory.repo  }}:$tag"
    digest_file="${archive_dir}/digest.txt"
    kaniko_executor_global_options="--destination=${destination} --digest-file=${digest_file}"
    {{- if has . "build_args" }}
    {{- range .build_args }}
    kaniko_executor_global_options="$kaniko_executor_global_options --build-arg {{.}}"
    {{- end }}
    {{- end }}

{{- if has . "context" }}
    # just build it with native build from git repo's dockerfile
    $kaniko_executor $kaniko_executor_global_options --context {{ .context }} --dockerfile {{ .dockerfile }}
{{- else }}

    # Prepare build context for image building.
    echo "Prepare build context for image: $destination ..."
    {{- $files := (.files | jq `map(select(.if != false ))`) -}}
    {{- $localFiles := ($files | jq `map(select(.src.type == "local" or .src.type == null))`) -}}
    {{- $ociFiles := $files | jq `map(select(.src.type == "oci"))` -}}
    {{- $httpFiles := $files | jq `map(select(.src.type == "http"))` -}}

    {{- if gt (len $localFiles) 0 }}
    ## local files
    {{- range $localFiles }}
    # - {{ .name }}
    mkdir -p "$(dirname ${archive_dir}/{{ .name }})"
    {{- if has .src "extract" }}
    tar -zxvf {{ .src.path }} --strip-components={{ math.Sub (strings.Split `/` (default "" .src.extract_inner_path) | len) 1 }} -C $archive_dir {{ default "" .src.extract_inner_path }}
    mv {{ default "" .src.extract_inner_path }} ${archive_dir}/{{ .name }}
    {{- else }}
    cp -r {{ .src.path }} ${archive_dir}/{{ .name }}
    {{- end }}
    {{- end }}
    {{- end }}

    {{- if gt (len $ociFiles) 0 }}
    ## compose files from OCI repositories.
    {{- range $ociFiles }}
    # {{ .name }}
    oras pull {{ .src.url }}
    mkdir -p $(dirname ${archive_dir}/{{ .name }})
    {{- if has .src "extract" }}
    tar -zxvf {{ .src.path }} --strip-components={{ math.Sub (strings.Split `/` (default "" .src.extract_inner_path) | len) 1 }} -C $archive_dir {{ default "" .src.extract_inner_path }}
    mv {{ default "" .src.extract_inner_path }} {{ .name }}
    {{- else }}
    cp -r {{ .src.path }} ${archive_dir}/{{ .name }}
    {{- end }}
    {{- end }}
    {{- end }}

    {{- if gt (len $httpFiles) 0 }}
    ## compose files from http.
    {{- range $httpFiles }}
    # {{ .name }}
    wget {{ .src.url }}
    mkdir -p $(dirname ${archive_dir}/{{ .name }})
    {{- if has .src "extract" }}
    tar -zxvf {{ path.Base .src.url }} --strip-components={{ math.Sub (strings.Split `/` (default "" .src.extract_inner_path) | len) 1 }} -C $archive_dir {{ default "" .src.extract_inner_path }}
    {{- else }}
    cp -r {{ .src.path }} ${archive_dir}/{{ .name }}
    {{- end }}
    {{- end }}
    {{- end }}
    ## build and push
    dockerfile="{{ .dockerfile }}"
    # get dockerfile from url if the `.dockerfile` value is a http url.
    if [ "${dockerfile#https://}" != "$dockerfile" ] || [ "${dockerfile#http://}" != "$dockerfile" ]; then
        echo "URL starts with https:// or http://, now I will download it and save it into: '$archive_dir/Dockerfile'."
        wget "$dockerfile" -O "$archive_dir/Dockerfile"
        dockerfile="$archive_dir/Dockerfile"
    fi
    dockerfile="$(realpath $dockerfile)"

    $kaniko_executor $kaniko_executor_global_options --context="$archive_dir" --dockerfile="$dockerfile"
{{- end }}

    # Save digest file path for later use
    cat "$digest_file" >> "$release_ws/digests.txt"
    rm -rf $archive_dir
    echo "Pushed image: $destination"
    # <<<<<<<<<<<<<<<< image: {{ .name }} <<<<<<<<<<<<<<<<
{{ end }}
    # All pushed.

    # Write results to file.
    write_push_results "$result_file" "$release_ws/digests.txt"

    # All done.
}

write_push_results() {
    result_file="$1"
    input_disgests_file="$2"

    tag="{{ index .artifactory.tags 0 }}-{{ .profile }}_{{ .os }}_{{ .arch }}"

    cat <<EOF > "$result_file"
images:
{{- range (.artifacts | jq `map(select(.type == "image"))`) }}
- repo: {{ .artifactory.repo  }}
  url: "{{ .artifactory.repo  }}:$tag"
  tag: "$tag"
  digest: '$(sed -n "$((i++))p" $input_disgests_file)'
{{- end }}
EOF
}

main "$@"
